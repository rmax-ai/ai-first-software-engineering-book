SYSTEM
# Writer Role Prompt (Contract)

You are the **Writer** role in a deterministic refinement loop.

You edit exactly one chapter. You do not decide when to stop.

## Inputs

- Chapter content (markdown)
- Planner output JSON

## Output

- Output the **full revised chapter markdown**.
- No commentary. No meta-explanations. No JSON.

## Hard constraints

- Preserve the **heading structure and ordering**. Do not add/remove/rename headings.
- Only modify sections that the Planner declared (kernel enforces).
- Keep changes localized; do not rewrite the entire document.
- Do not introduce marketing language, anthropomorphism, or vague claims.
- If adding a diagram, use Mermaid and place it where the Planner specified.

## Prose constraints

- Keep sentence lengths reasonable.
- Prefer concrete examples with measurable outcomes.
- Include trade-offs and operational risks where relevant.


USER
Output the full revised chapter markdown only. No code fences.

===CHAPTER_START===
# Chapter 03 — Autonomous Kernels

## Thesis
An autonomous kernel is a minimal, well-specified control loop that executes bounded work: plan, apply tool actions, verify, and stop. Its constraints (budgets, permissions, evaluation gates) define a safety envelope that makes outcomes inspectable and repeatable.

Definitions:
- **Autonomous kernel**: a control loop with explicit limits and explicit exit criteria; it is not “general autonomy,” long-horizon project management, or open-ended exploration.
- **Budget**: a hard cap on resources (iterations, elapsed time, tool calls, diff size) that prevents runaway behavior and forces escalation when progress stalls.
- **Evaluation gate**: a required check whose result must be recorded and must be satisfied (or explicitly waived with justification) before the kernel can declare success.

Hypothesis: small, well-governed autonomous kernels (tight loops with explicit budgets and evaluation gates) outperform broad autonomy in stability and debuggability.

## Why This Matters
- Most failures in agentic work are operational: runaway loops, untraceable edits, and unverifiable outcomes.
- Kernels enable composability: multiple kernels can run with different permissions and evaluation profiles.
- “Kernel-first” design makes autonomy a system property, not a prompt trick.

## System Breakdown
- **Kernel loop**: intent → plan → act → verify → record trace → stop/iterate.
- **Budgets**: max iterations, time, tool calls, diff size.
- **Permissions**: read/write scopes, protected paths, allowed tools.
- **Verification**: mandatory checks per action class (e.g., tests for code changes).
- **Persistence**: ledger entries, trace logs, artifacts.

To make this operational, treat each loop step as a checkpoint with a “must record” trace payload and a “must decide” stop condition:
- **Intent**: state the task class and success condition (e.g., “tests pass,” “build passes,” “repro no longer fails”).
- **Plan**: enumerate the next 1–3 actions only (not the whole project), each tied to a verification gate and a budget slice.
- **Act**: perform the minimal change that addresses the current hypothesis; avoid speculative edits that cannot be evaluated.
- **Verify**: run the smallest evaluation that is credible for the task class. Use unit tests for logic changes and typecheck/build for dependency changes; use end-to-end only when required. Verification can fail in two ways: the check fails, or the check is too narrow to detect the real regression.
- **Record trace**: persist commands executed, files touched, diff stats, and evaluation outputs (or hashes/pointers to them) so a human can replay or audit.
- **Stop/iterate**: stop when the success condition is met, or when a budget is exhausted, or when verification indicates the current plan cannot succeed without broader permissions/scope.

Mermaid mapping of stages to controls and outputs:

```mermaid
flowchart LR
  I[Intent] --> P[Plan] --> A[Act] --> V[Verify] --> R[Record trace] --> S{Stop / iterate}

  B[(Budgets\niterations/time/tool calls/diff size)] -. constrains .-> P
  B -. constrains .-> A
  B -. constrains .-> V
  Perm[(Permissions\nread/write scopes\nprotected paths\nallowed tools)] -. constrains .-> A
  Gate[(Evaluation gates\nby action class)] -. required .-> V
  Persist[(Persistence\nledger/trace logs/artifacts)] -. produced .-> R

  V -->|pass| S
  V -->|fail| P
  S -->|iterate| P
  S -->|stop| End[Exit with summary]
```

A compact “must capture” checklist (minimum viable trace):
| Loop stage | Budget signal | Permission signal | Verification signal | Persistence artifact |
|---|---|---|---|---|
| intent | remaining iterations/time | required read scope | success criteria defined | intent string + criteria |
| plan | tool-call budget allocation | allowed tools list | planned gates named | plan steps + gate mapping |
| act | diff size consumed | write scope used | N/A | patch/diff stats |
| verify | time/tool calls consumed | execution permissions | gate results (pass/fail) | command + exit code + excerpt |
| record trace | N/A | N/A | N/A | ledger entry + trace pointer |
| stop/iterate | budget exhausted? | permission insufficient? | gates satisfied? | final summary + next action |

## Concrete Example 1
Bug-fix kernel for a CLI tool.

- Input:
  - failing test case: `tests/test_parse.py::test_rejects_empty_input`
  - reproduction step: `python -m mycli parse ""` returns exit code `0` but should return non-zero
  - budgets: max 3 iterations, max 10 tool calls, max 40 lines changed
  - permissions: read `src/`, write `src/parser.py`, run `pytest -k parse`

Mini-runbook (a single bounded kernel run):
1. Localize failure (evidence-first)
   - Action: run the smallest check that reproduces the failure.
     - Command: `pytest -k rejects_empty_input`
   - Record:
     - failing assertion excerpt (placeholder): `E assert 0 == 2`
     - environment notes: OS, Python version, CLI args
   - Stop/iterate rule:
     - If the failure does not reproduce, stop and return “cannot reproduce” trace (do not edit).

2. Patch minimal surface (hypothesis-driven)
   - Hypothesis: empty string is being treated as a valid token stream in `src/parser.py`.
   - Action: make a minimal edit that rejects empty input at the boundary (not across unrelated call sites).
   - Budget check:
     - ensure diff size stays within 40 lines and touches only `src/parser.py` (or a single adjacent file if necessary).
   - Record:
     - files touched: `src/parser.py`
     - diff stats: `+6 -1` (placeholder)

3. Run verification gate (tight but credible)
   - Gate 1: rerun the failing test.
     - Command: `pytest -k rejects_empty_input`
   - Gate 2 (cheap regression check): run related unit tests only.
     - Command: `pytest -k parse`
   - Verification risk handling:
     - If Gate 1 passes but Gate 2 fails, treat as “not fixed” (the patch likely broke a nearby invariant).

4. Record trace (auditable, replayable)
   - Persist a kernel trace with:
     - budgets consumed: iterations used, tool calls used, diff size
     - commands executed + exit codes
     - final test summary line (placeholder): `2 passed, 0 failed`
   - Write a ledger entry summarizing:
     - what changed (one-sentence)
     - why it changed (link to failing assertion)
     - what verified it (gate list)

5. Stop criteria (explicit)
   - Stop success: Gate 1 and Gate 2 pass within budget.
   - Stop failure: tool-call budget exhausted, diff budget exceeded, or verification indicates a broader refactor is required.
   - Stop escalation output: include “next action for a human” (e.g., “needs design change in tokenization; requires editing `src/lexer.py`, which is outside current write scope”).

## Concrete Example 2
Dependency upgrade kernel.

- Input:
  - target version: `libX 4.2.0 → 4.3.0`
  - constraints: Python `>=3.10`, cannot change public API, CI must stay green
  - upgrade guide: notes a breaking rename `OldClient` → `Client`
  - budgets: max 4 iterations, max 15 tool calls, max 120 lines changed
  - permissions: write `pyproject.toml` and `src/`, run `python -m compileall` and `pytest`

Kernel steps with an explicit remediation branch:
1. Update manifest (narrow scope)
   - Action: bump version constraint in `pyproject.toml`.
   - Record:
     - old/new constraint strings
     - diff stats for manifest only
   - Stop/iterate rule:
     - If the dependency resolver cannot produce a consistent lock, stop with resolver output (do not attempt ad-hoc pinning unless that is explicitly in scope).

2. Run a fast build/type gate before full tests
   - Gate A (fast): import/type/compile smoke check.
     - Command: `python -m compileall src`
   - Record:
     - exit code
     - compile summary line (placeholder): `Listing 'src'...` … `compileall: success` (or equivalent)
   - Interpretation:
     - If Gate A fails, this is often a missing symbol or incompatible API that will be faster to remediate than running the full suite.

3. Remediation branch (compile errors vs failing tests)
   - If **compile/import fails**:
     - Localize: identify first error site (file + symbol).
     - Patch: apply the minimal mechanical fix (e.g., rename `OldClient` to `Client`) in the smallest set of files.
     - Verify: rerun Gate A only, then proceed.
     - Budget guard:
       - If more than 5 files are touched, stop and escalate (“requires broader refactor”).
       - If the cumulative diff exceeds 120 lines changed, stop and escalate (“exceeds change budget for this kernel”).
   - If **compile passes but tests fail**:
     - Localize: run the single failing test file or test case.
     - Patch: address behavioral change (e.g., new default timeout) with a targeted adjustment and a justification in the trace.
     - Verify: rerun the failing tests, then run the full relevant suite.

4. Run full verification gate (credibility gate)
   - Gate B (full): run the test suite (or the project’s standard verification command).
     - Command: `pytest`
   - Record:
     - exit code
     - test summary line (placeholder): `X passed, 0 failed` (or, on failure, `X passed, Y failed`)
   - Verification risk handling:
     - Treat a narrowed verification set as a failure mode unless the trace records why it is acceptable (e.g., “no integration tests exist; unit suite is the highest available gate”).

5. Stop criteria and outputs
   - Stop success: Gate A and Gate B pass within budget.
   - Stop failure: repeated failures indicate the upgrade exceeds current permission/scope (e.g., requires API redesign), or budgets are exhausted.
   - Required outputs on stop:
     - change summary: files touched + primary reason
     - verification summary: Gate A command + result and Gate B command + result, including summary lines
     - rollback plan: “revert manifest bump and lockfile” (or equivalent) with the exact files to revert

## Trade-offs
- Smaller kernels reduce risk but may require orchestration for multi-step projects.
  - Mitigation: use staged kernels (e.g., “diagnose-only” kernel → “patch” kernel → “refactor” kernel), each with separate budgets and permissions.
- Strict permissions reduce blast radius but can prevent necessary refactors.
  - Mitigation: use permission escalation as an explicit step with a justification and a widened verification gate (e.g., requiring a broader test suite when write scope expands).
- Heavier tracing improves auditability but adds operational overhead.
  - Mitigation: record a minimum viable trace by default (commands, diffs, gate results), and sample/expand traces only on failures or high-risk task classes.

## Failure Modes
- **Local minima**: kernel makes safe micro-edits without addressing root cause.
- **Tool thrash**: too many actions with low information gain.
- **False confidence**: passing a narrow eval set while violating higher-level requirements.

Detection signals (tie these to budgets and evaluation gates, not intuition):
- Local minima:
  - repeated edits in the same small area with no change in verification outcome across iterations
  - steadily increasing diff size without new evidence (no new failing test localized, no new reproduction)
- Tool thrash:
  - tool-call count rising while the plan does not change (same commands rerun without a new hypothesis)
  - frequent context switches (many files touched) despite a small, bounded intent
- False confidence:
  - verification gates becoming narrower over time (“only reran one test”) without a recorded justification
  - “green” on fast gates but repeated regressions reported elsewhere (signals the gate set is mis-specified for the task class)
  - success declared without a trace artifact that includes gate results and the exact commands used

## Research Directions
- Kernel composition patterns (delegation, staged permissions, multi-kernel workflows).
- Automatic stop-condition tuning based on task class.
- Replayable kernels for deterministic debugging of agent behavior.
===CHAPTER_END===

===PLANNER_JSON_START===
{
  "focus_areas": [
    "## Thesis: tighten scope"
  ],
  "risk_flags": [
    "possible repetition"
  ],
  "structural_changes": [],
  "target_word_delta": "+0"
}
===PLANNER_JSON_END===

